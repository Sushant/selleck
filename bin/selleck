#!/usr/bin/env node
/*
Selleck
Copyright (c) 2011 Yahoo! Inc.
Licensed under the BSD License.
*/

var fs        = require('fs'),
    fsPath    = require('path'),

    selleck   = require('selleck'),
    fileutils = require('selleck/lib/fileutils'),
    higgins   = require('selleck/lib/higgins'),
    util      = require('selleck/lib/util'), // Selleck's util, not Node's util.

    arg,
    args  = [], // leftover args after params are parsed out of argv
    argv  = process.argv.slice(2), // get rid of the leading 'node' arg
    docs  = {components: []},
    log   = selleck.log,

    nextArg,

    // Default values for command line options.
    options  = {
        'out'         : './docs',
        'out-ext'     : '.html',
        'overrideMeta': {},
        'theme'       : selleck.defaultTheme
    },

    projectLayouts  = {},
    projectMeta     = {},
    projectPages    = {},
    projectPartials = {},

    themeLayouts  = {},
    themeMeta     = {},
    themePartials = {},

    help = [
        "Selleck generates YUI user documentation, Mustache-style.",
        "",
        "Usage: selleck [options] [input path]",
        "",
        "Common Options:",
        "  -m, --meta <filename>  Augment and override project/component metadata with",
        "                         data in the specified file.",
        "  -o, --out <path>       Write generated files to this output path.",
        "  -p, --project <path>   Use the specified project path instead of searching for",
        "                         the project.",
        "  -s, --server [port]    Run Selleck as a web server for real-time previews of",
        "                         changes while editing docs.",
        "  -t, --theme <path>     Use the specified theme instead of the default.",
        "  -h, --help             Display this help message.",
        "  -v, --version          Display version information.",
        "",
        "Advanced Options:",
        "  --out-assets <path>    Copy all assets to this output path instead of the",
        "                         default. Component assets will be copied to",
        "                         subdirectories named for the component.",
        "  --out-ext <extension>  Use the specified file extension for generated pages",
        "                         instead of the default (.html).",
        "  --out-meta <filename>  Write combined project and component JSON metadata to",
        "                         the specified filename.",
        ""
    ].join('\n');

// Process command line parameters.
while ((arg = argv.shift())) {
    // If this isn't a parameter, push it onto the leftover args stack and move
    // on.
    if (arg.indexOf('-') !== 0) {
        args.push(arg);
        continue;
    }

    switch (arg) {
    case '--help':
    case '-h':
        // WTF. This is seriously the only way I've been able to figure out to
        // make Node reliably flush to stdout before exiting. It's ridiculous.
        // This is stupid. 
        process.stdout.write(help);
        while (!process.stdout.flush()) {};
        process.exit();
        break;

    case '--metadata':
    case '--meta':
    case '-m':
        options.overrideMeta = JSON.parse(fs.readFileSync(argv.shift(), 'utf8'));
        break;

    case '--output':
    case '--out':
    case '-o':
        options.out = argv.shift();
        break;

    case '--output-assets':
    case '--out-assets':
        options['out-assets'] = argv.shift();
        break;

    case '--output-extension':
    case '--output-ext':
    case '--out-extension':
    case '--out-ext':
        options['out-ext'] = argv.shift();
        break;

    case '--output-metadata':
    case '--output-meta':
    case '--out-metadata':
    case '--out-meta':
        options['out-meta'] = argv.shift();
        break;

    case '--project':
    case '-p':
        options.project = docs.project = {path: argv.shift()};

        if (!selleck.isProjectDirectory(docs.project.path)) {
            log('Invalid project path: ' + docs.project.path, 'error');
            process.exit(1);
        }
        break;

    case '--server':
    case '--serve':
    case '-s':
        options.server = true;

        if ((nextArg = argv.shift())) {
            if (nextArg.search(/^\d+$/) === -1) {
                // Not a port number; put the argument back on the argv array.
                argv.unshift(nextArg);
            } else {
                options.serverPort = +nextArg;
            }
        }
        break;

    case '--theme':
    case '-t':
        options.theme = argv.shift();
        break;

    case '--version':
    case '-v':
        pkg = JSON.parse(fs.readFileSync(__dirname + '/../package.json', 'utf-8'));

        version = [
            "Selleck " + pkg.version,
            pkg.copyright,
            pkg.homepage,
            ""
        ].join('\n');

        // See rant above re. forcing Node to flush stdout before exiting.
        process.stdout.write(version);
        while (!process.stdout.flush()) {};
        process.exit();
        break;

    default:
        log('Unrecognized parameter: ' + arg, 'error');
        process.exit(1);
    }
}

// First leftover arg (if any) is the root path; if no arg, then use the current
// directory.
options.rootPath = args.shift() || process.cwd();

options['out-assets'] || (options['out-assets'] = fsPath.join(options.out, 'assets'));

if (options.server) {
    // If running as a server, start the server instead of continuing.
    require('selleck/lib/server')(options);
} else {
    selleck.createOutputDir(options.out);
    selleck.createOutputDir(options['out-assets']);

    // Load theme layouts and partials, and copy theme assets to the output dir,
    // if there are any.
    themeLayouts  = selleck.getLayouts(options.theme);
    themeMeta     = selleck.getMetadata(options.theme, 'theme');
    themePartials = selleck.getPartials(options.theme);

    selleck.copyAssets(fsPath.join(options.theme, 'assets'),
            options['out-assets'], true, function (err) {

        if (err) {
            log(err.message, 'error');
            process.exit(1);
        }
    });

    // Traverse the root path and look for documentation directories.
    docs = selleck.findDocs(options.rootPath, docs);

    if (docs.project) {
        projectLayouts  = util.merge(themeLayouts, selleck.getLayouts(docs.project.path));
        projectMeta     = util.merge(themeMeta, selleck.getMetadata(docs.project.path, 'project'));
        projectPartials = util.merge(themePartials, selleck.getPartials(docs.project.path));
        projectPages    = selleck.getPages(docs.project.path);

        log('Generating project docs for ' + docs.project.path, 'info');

        selleck.generate(docs.project.path, util.merge(options, {
            layouts  : projectLayouts,
            meta     : projectMeta,
            partials : projectPartials,
            pages    : projectPages,
            project  : true,
            skipLoad : true, // Don't reload stuff from the input dir.
            validator: projectValidator
        }), generateComponents);
    } else {
        generateComponents();
    }

    function generateComponents(err) {
        if (err) { return finish(err); }

        var toGenerate = docs.components.length;
        if (!toGenerate) { return finish(); }

        // Generate component docs.
        docs.components.forEach(function(component) {
            var path = component.path;

            log('Generating component docs for ' + path, 'info');

            selleck.generate(path, util.merge(options, {
                component: true,
                layouts  : projectLayouts,
                meta     : projectMeta,
                partials : projectPartials,
                pages    : projectPages,
                validator: componentValidator
            }), finishComponent);
        });

        function finishComponent(err) {
            if (err) { return finish(err); }

            toGenerate -= 1;

            if (toGenerate === 0) {
                finish();
            }
        }
    }

    function finish(err) {
        if (err) {
            log(err, 'error');
            return;
        }

        var meta;

        if (options['out-meta']) {
            log('Writing combined metadata to ' + options['out-meta'], 'info');

            meta = {
                project: util.merge(projectMeta, options.overrideMeta),
                components: {}
            };

            docs.components.forEach(function (component) {
                var data = selleck.getMetadata(component.path, 'component');

                if (data && data.name) {
                    meta.components[data.name] = util.merge(
                        meta.project.componentDefaults || {},
                        data,
                        options.overrideMeta
                    );

                    delete meta.components[data.name].componentDefaults;
                }
            });

            fs.writeFile(options['out-meta'], JSON.stringify(meta), 'utf8', function (err) {
                if (err) {
                    log(err, 'error');
                } else {
                    reallyFinish();
                }
            });
        } else {
            reallyFinish();
        }

        function reallyFinish() {
            log('Done! Docs were written to: ' + options.out, 'info');
        }
    }
}

// -- Functions ----------------------------------------------------------------
function componentValidator(data, docPath) {
    // Validate the component name.
    if (!data.meta.name) {
        log('Component name not specified; skipping: ' + docPath, 'error');
        return false;
    }

    if (data.meta.name.search(/^[\w\-]+$/) === -1) {
        log('Invalid component name: ' + data.meta.name + '; skipping: ' + docPath, 'error');
        return false;
    }
}

function projectValidator(data, docPath) {
    if (!data.meta.projectName) {
        log('Project name not specified: ' + docPath, 'error');
        process.exit(1);
    }
}
