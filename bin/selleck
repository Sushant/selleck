#!/usr/bin/env node
/*
Selleck
Copyright (c) 2011 Yahoo! Inc.
Licensed under the BSD License.
*/

var selleck   = require('selleck'),
    fileutils = require('selleck/fileutils'),
    util      = require('selleck/util'), // selleck's util, not Node's util.

    arg,
    args  = [], // leftover args after params are parsed out of argv
    argv  = process.argv.slice(2), // get rid of the leading 'node' arg
    docs  = {components: []},
    log   = selleck.log,

    nextArg,

    // Default values for command line options.
    options  = {
        out  : './docs',
        theme: selleck.defaultTheme
    },

    projectLayouts  = {},
    projectMeta     = {},
    projectPages    = {},
    projectPartials = {},

    themeLayouts = {},

    help = [
        "Generates YUI user documentation, Mustache-style.",
        "",
        "Usage: selleck [options] [input path]",
        "",
        "Options:",
        "  -o, --out <path>      Write generated files to this output path.",
        "  -p, --project <path>  Use the specified project path instead of searching for",
        "                        the project.",
        "  -s, --server [port]   Run Selleck as a web server for real-time previews of",
        "                        changes while editing docs.",
        "  -t, --theme <path>    Use the specified theme instead of the default.",
        "  -h, --help            Display this help message.",
    ].join('\n');

// Process command line parameters.
while ((arg = argv.shift())) {
    // If this isn't a parameter, push it onto the leftover args stack and move
    // on.
    if (arg.indexOf('-') !== 0) {
        args.push(arg);
        continue;
    }

    switch (arg) {
    case '--help':
    case '-h':
        console.log(help);
        process.exit();
        break;

    case '--output':
    case '--out':
    case '-o':
        options.out = argv.shift();
        break;

    case '--project':
    case '-p':
        options.project = docs.project = {path: argv.shift()};

        if (!selleck.isProjectDirectory(docs.project.path)) {
            log('Invalid project path: ' + docs.project.path, 'error');
            process.exit(1);
        }
        break;

    case '--server':
    case '-s':
        options.server = true;

        if ((nextArg = argv.shift())) {
            if (nextArg.search(/^\d+$/) === -1) {
                // Not a port number; put the argument back on the argv array.
                argv.unshift(nextArg);
            } else {
                options.serverPort = +nextArg;
            }
        }
        break;

    case '--theme':
    case '-t':
        options.theme = argv.shift();
        break;

    default:
        log('Unrecognized parameter: ' + arg, 'error');
        process.exit(1);
    }
}

// TODO: Theme assets need to be merged (at lowest priority) with project/component assets. Or maybe placed in a special "theme" directory.
// TODO: Theme layouts need to be merged (at lowest priority) with project/component layouts.

// First leftover arg (if any) is the root path; if no arg, then use the current
// directory.
options.rootPath = args.shift() || process.cwd();

// If running as a server, start the server instead of continuing.
if (options.server) {
    require('selleck/server')(options);
} else {
    selleck.createOutputDir(options.out);

    // Load theme layouts and copy theme assets to the output dir, if there are
    // any.
    themeLayouts = selleck.getLayouts(options.theme);

    selleck.copyAssets(options.theme, options.out, true, function (err) {
        if (err) {
            log(err.message, 'error');
            process.exit(1);
        }
    });

    // Traverse the root path and look for documentation directories.
    docs = selleck.findDocs(options.rootPath, docs);

    if (docs.project) {
        projectLayouts  = util.merge(themeLayouts, selleck.getLayouts(docs.project.path));
        projectMeta     = selleck.getMetadata(docs.project.path, 'project');
        projectPartials = selleck.getPartials(docs.project.path);
        projectPages    = selleck.getPages(docs.project.path);

        log('Generating project docs for ' + docs.project.path, 'info');

        selleck.generate(docs.project.path, options.out, {
            layouts  : projectLayouts,
            meta     : projectMeta,
            partials : projectPartials,
            pages    : projectPages,
            project  : true,
            skipLoad : true, // Don't reload stuff from the input dir.
            validator: projectValidator
        });
    }

    // Generate component docs.
    docs.components.forEach(function(component) {
        var path = component.path;

        log('Generating component docs for ' + path, 'info');

        selleck.generate(path, options.out, {
            component: true,
            layouts  : projectLayouts,
            meta     : projectMeta,
            partials : projectPartials,
            pages    : projectPages,
            validator: componentValidator
        });
    });

    log('Done! Docs were written to: ' + options.out, 'info');
}

// -- Functions ----------------------------------------------------------------
function componentValidator(data, docPath) {
    // Validate the component name.
    if (!data.meta.name) {
        log('Component name not specified; skipping: ' + docPath, 'error');
        return false;
    }

    if (data.meta.name.search(/^[\w\-]+$/) === -1) {
        log('Invalid component name: ' + data.meta.name + '; skipping: ' + docPath, 'error');
        return false;
    }
}

function projectValidator(data, docPath) {
    if (!data.meta.projectName) {
        log('Project name not specified: ' + docPath, 'error');
        process.exit(1);
    }
}
